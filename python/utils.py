import os.path
from pathlib import Path

LOSSES = {
    'MSE': 'MeanSquaredError',
    'POISSON_DEVIANCE': 'PoissonDeviance',
    'NEGATIVE_BINOMIAL_DEVIANCE': 'NegativeBinomialDeviance',
    'NON_CROSSING_LORENZ': 'NonCrossingLorenzCurveError',
    'CROSSING_LORENZ': 'CrossingLorenzCurveError'
}
DTYPES = {
    'FLOAT32': 'CART_FLOAT32',
    'FLOAT64': 'CART_FLOAT64'
}

HEADER = '''/*
***** This file SHOULD NOT be modified directly: it is generated by python/utils.py *****
*/

#define BRT(F, L) Cart::Regression::BaseRegressionTree<F, Cart::Loss::L<F>>

'''

FUNCTION_ARGS = [
    (
        'FIT',
        'static_cast<BRT(F, L)*>(tree)->fit(*static_cast<Cart::Dataset<F>*>(dataset))',
        'void* tree, void* dataset'
    ),
    (
        'PREDICT',
        '''do {                                                  \\
        Cart::Array<F> _out(static_cast<F*>(out), n, false);     \\
        Cart::Array<F> _X(static_cast<F*>(X), n*nb_dims, false); \\
        static_cast<BRT(F, L)*>(tree)->predict(_X, _out);        \\
        } while(false)''',
        'void* tree, void* X, void* out, int n, int nb_dims'
    ),
    (
        'CREATE',
        '''do {                                                   \\
        *reinterpret_cast<BRT(F, L)**>(tree) = new BRT(F, L)(*config); \\
        } while(false)''',
        'void** tree, Cart::TreeConfig* config'
    ),
    (
        'DELETE',
        'delete static_cast<BRT(F, L)*>(tree)',
        'void* tree'
    ),
    (
        'GET_NB_INTERNAL_NODES',
        '''do {                                                                 \\
            *size = static_cast<BRT(F, L)*>(tree)->get_internal_nodes().size(); \\
        } while(false)''',
        'void* tree, size_t* size'
    ),
    (
        'GET_FEATURE_IMPORTANCE',
        'static_cast<BRT(F, L)*>(tree)->get_feature_importance(static_cast<F*>(array))',
        'void* tree, void* array'
    ),
    (
        'GET_ROOT',
        '''do { \\
            *ret = static_cast<void*>(const_cast<Cart::Node<F>*>(static_cast<BRT(F, L)*>(tree)->get_root())); \\
        } while(false)''',
        'void* tree, void** ret'
    ),
    (
        'RECALIBRATE',
        'static_cast<BRT(F, L)*>(tree)->recalibrate(static_cast<Cart::Dataset<F>*>(dataset))',
        'void* tree, void* dataset'
    )
]


def make_function(def_name, def_value, args='void* tree'):
    function = []
    fct_name = f'CALL_{def_name}_TREE'
    fct_args = f'{args}, __FloatingPoint fp, __Loss loss'
    function.append(f'static inline void {fct_name}({fct_args}) {{')
    function.append(f'#define {def_name}(F, L) {def_value}')
    first = True
    for loss in LOSSES.keys():
        for dtype in DTYPES.keys():
            if first:
                first = False
                IF = 'if'
            else:
                IF = '} else if'
            cond_dtype = f'fp == __FloatingPoint::{dtype}'
            cond_loss = f'loss == __Loss::{loss}'
            function.append(f'    {IF}({cond_dtype} and {cond_loss}) {{')
            function.append(f'        {def_name}({DTYPES[dtype]}, {LOSSES[loss]});')
    function.append('    } else {')
    function.append('        throw std::runtime_error("Wrong loss or dtype");')
    function.append('    }')
    function.append(f'#undef {def_name}')
    function.append('}')
    return function

def make_cpp_wrapper():
    dirname = os.path.dirname(os.path.abspath(__file__))
    with open(Path(dirname) / '__pycart_calls.hpp', 'w') as f:
        f.write(HEADER)
        for args in FUNCTION_ARGS:
            f.write('\n'.join(make_function(*args)))
            f.write('\n\n')
        f.write('#undef BRT\n')


if __name__ == '__main__':
    make_cpp_wrapper()
